<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç”µå­é€å¡ç›¸æœº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-fallback {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            align-items: center;
            justify-content: center;
        }

        .video-fallback.active {
            display: flex;
        }

        .video-fallback-text {
            color: white;
            font-size: 18px;
            text-align: center;
            padding: 20px;
        }

        #overlay {
            position: relative;
            max-width: 80vw;
            max-height: 80vh;
            pointer-events: none;
            display: none;
        }

        #overlay.visible {
            display: block;
        }

        .overlay-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            cursor: move;
            touch-action: none;
            z-index: 50;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px 20px 0 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
        }

        .slider-container label {
            color: white;
            font-size: 14px;
            white-space: nowrap;
        }

        #scaleSlider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        #scaleSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        button {
            padding: 14px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            -webkit-transition: transform 0.2s, opacity 0.2s;
        }

        #rotateSlider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        #rotateSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: scale(0.95);
            -webkit-transform: scale(0.95);
        }

        #uploadBtn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            flex: 1;
        }

        #captureBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        #resetBtn {
            background: rgba(255, 107, 107, 0.9);
            color: white;
            padding: 14px;
        }

        .hidden {
            display: none !important;
        }

        #fileInput {
            display: none;
        }

        .tip {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            padding: 0 10px;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }

        .loading::after {
            content: '';
            display: block;
            width: 40px;
            height: 40px;
            margin: 15px auto;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .preset-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            padding: 0 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .preset-card {
            flex-shrink: 0;
            width: 70px;
            height: 70px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        .preset-card:hover, .preset-card.active {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
            transform: scale(1.1);
        }

        .preset-card-label {
            font-size: 10px;
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.7);
        }

        .background-remover {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            z-index: 300;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .background-remover.active {
            display: block;
        }

        .background-remover h3 {
            color: white;
            margin-bottom: 20px;
            text-align: center;
        }

        .remover-controls {
            margin: 20px 0;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .color-picker-container label {
            color: white;
            font-size: 14px;
        }

        #bgColorPicker {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .tolerance-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tolerance-container label {
            color: white;
            font-size: 14px;
            white-space: nowrap;
        }

        #toleranceSlider {
            flex: 1;
        }

        .preview-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .preview-box {
            text-align: center;
        }

        .preview-box canvas {
            max-width: 150px;
            max-height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .preview-box p {
            color: white;
            font-size: 12px;
            margin-top: 8px;
        }

        .remover-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .remover-buttons button {
            padding: 10px 20px;
            font-size: 14px;
        }

        .close-remover {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }

        /* é¢„è§ˆå¼¹çª—æ ·å¼ */
        .preview-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 20px;
            z-index: 400;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .preview-modal.active {
            display: block;
        }

        .preview-modal h3 {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .preview-modal img {
            max-width: 100%;
            max-height: 70vh;
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
        }

        .preview-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .preview-buttons button {
            padding: 12px 30px;
            font-size: 14px;
        }

        .close-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">æ­£åœ¨åŠ è½½ç›¸æœº...</div>

    <div class="container">
        <video id="video" autoplay playsinline muted></video>
        <div class="video-fallback" id="videoFallback">
            <div class="video-fallback-text">
                <p>ç›¸æœºä¸å¯ç”¨</p>
                <p style="font-size: 14px; margin-top: 10px;">ä½¿ç”¨æ¸å˜èƒŒæ™¯ä½œä¸ºé¢„è§ˆ</p>
            </div>
        </div>
        <div class="overlay-wrapper" id="overlayWrapper">
            <img id="overlay" src="" alt="">
        </div>
    </div>

    <div class="controls">
        <div class="slider-container">
            <label>ç¼©æ”¾:</label>
            <input type="range" id="scaleSlider" min="20" max="200" value="100">
            <label id="scaleValue">100%</label>
        </div>
        
        <div class="preset-selector">
            <div class="preset-card" data-preset="polaroid">
                <div>ğŸ“·</div>
                <div class="preset-card-label">æ‹ç«‹å¾—</div>
            </div>
            <div class="preset-card" data-preset="vintage">
                <div>ğŸï¸</div>
                <div class="preset-card-label">å¤å¤</div>
            </div>
            <div class="preset-card" data-preset="film">
                <div>ğŸ¬</div>
                <div class="preset-card-label">èƒ¶å·</div>
            </div>
            <div class="preset-card" data-preset="custom">
                <div>â•</div>
                <div class="preset-card-label">è‡ªå®šä¹‰</div>
            </div>
        </div>
        
        <div class="tip">æ‹–æ‹½è°ƒæ•´ä½ç½® Â· åŒæŒ‡ç¼©æ”¾æˆ–æ»‘åŠ¨æ¡è°ƒæ•´å¤§å°</div>

        <div class="slider-container">
            <label>æ—‹è½¬:</label>
            <button id="rotateLeftBtn" style="padding: 8px 12px; font-size: 14px;">â†º</button>
            <input type="range" id="rotateSlider" min="-180" max="180" value="0" style="flex: 1;">
            <button id="rotateRightBtn" style="padding: 8px 12px; font-size: 14px;">â†»</button>
            <label id="rotateValue">0Â°</label>
        </div>

        <div class="button-row">
            <button id="uploadBtn">ğŸ“· ä¸Šä¼ é€å¡</button>
            <button id="captureBtn">ğŸ“¸ æ‹ç…§ä¿å­˜</button>
            <button id="resetBtn">â†»</button>
        </div>
        
        <div class="button-row" style="margin-top: 10px;">
            <button id="debugBtn" style="background: rgba(100, 100, 255, 0.9); color: white; padding: 8px 16px; font-size: 12px;">ğŸ”§ è°ƒè¯•ä¿¡æ¯</button>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/png,image/*">
    <canvas id="canvas" class="hidden"></canvas>

    <!-- èƒŒæ™¯ç§»é™¤å¼¹çª— -->
    <div class="background-remover" id="bgRemover">
        <button class="close-remover" id="closeRemover">Ã—</button>
        <h3>ğŸ¨ æ™ºèƒ½èƒŒæ™¯ç§»é™¤</h3>

        <div class="preview-container">
            <div class="preview-box">
                <canvas id="originalPreview"></canvas>
                <p>åŸå§‹å›¾ç‰‡</p>
            </div>
            <div class="preview-box">
                <canvas id="processedPreview"></canvas>
                <p>é¢„è§ˆæ•ˆæœ</p>
            </div>
        </div>

        <div class="remover-controls">
            <div class="color-picker-container" style="margin-bottom: 20px;">
                <label>ç‚¹å‡»å³ä¾§æŒ‰é’®é€‰æ‹©è¦ç§»é™¤çš„èƒŒæ™¯è‰²:</label>
                <input type="color" id="bgColorPicker" value="#ffffff">
                <button id="autoDetectBtn" style="background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 16px; font-size: 12px; margin-left: 10px;">ğŸ” è‡ªåŠ¨æ£€æµ‹</button>
            </div>

            <div class="tolerance-container">
                <label>å®¹å·®:</label>
                <input type="range" id="toleranceSlider" min="0" max="100" value="30">
                <label id="toleranceValue">30</label>
            </div>

            <div class="tolerance-container" style="margin-top: 15px;">
                <label>ç¾½åŒ–:</label>
                <input type="range" id="featherSlider" min="0" max="20" value="3">
                <label id="featherValue">3</label>
            </div>
        </div>

        <div class="remover-buttons">
            <button id="applyRemover" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">åº”ç”¨é€æ˜èƒŒæ™¯</button>
            <button id="skipRemover" style="background: rgba(255, 255, 255, 0.3); color: white;">è·³è¿‡ï¼ˆä½¿ç”¨åŸå›¾ï¼‰</button>
        </div>
    </div>

    <!-- é¢„è§ˆå¼¹çª— -->
    <div class="preview-modal" id="previewModal">
        <button class="close-preview" id="closePreview">Ã—</button>
        <h3>ğŸ“¸ ç…§ç‰‡é¢„è§ˆ</h3>
        <img id="previewImage" src="" alt="é¢„è§ˆå›¾ç‰‡">
        <div class="preview-buttons">
            <button id="saveBtn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">ğŸ’¾ ä¿å­˜ç…§ç‰‡</button>
            <button id="retakeBtn" style="background: rgba(255, 107, 107, 0.9); color: white;">ğŸ”„ é‡æ‹</button>
        </div>
    </div>

    <script>
        // DOM å…ƒç´ 
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const overlayWrapper = document.getElementById('overlayWrapper');
        const uploadBtn = document.getElementById('uploadBtn');
        const captureBtn = document.getElementById('captureBtn');
        const resetBtn = document.getElementById('resetBtn');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');
        const rotateSlider = document.getElementById('rotateSlider');
        const rotateValue = document.getElementById('rotateValue');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const loading = document.getElementById('loading');
        const presetCards = document.querySelectorAll('.preset-card');

        // èƒŒæ™¯ç§»é™¤ç›¸å…³å…ƒç´ 
        const bgRemover = document.getElementById('bgRemover');
        const closeRemover = document.getElementById('closeRemover');
        const originalPreview = document.getElementById('originalPreview');
        const processedPreview = document.getElementById('processedPreview');
        const bgColorPicker = document.getElementById('bgColorPicker');
        const toleranceSlider = document.getElementById('toleranceSlider');
        const toleranceValue = document.getElementById('toleranceValue');
        const applyRemover = document.getElementById('applyRemover');
        const cancelRemover = document.getElementById('cancelRemover');

        // é¢„è®¾é€å¡ï¼ˆä½¿ç”¨ Canvas ç”Ÿæˆï¼‰
        const presets = {
            polaroid: generatePolaroidCard(),
            vintage: generateVintageCard(),
            film: generateFilmCard()
        };

        let currentPreset = null;
        let uploadedImageData = null;
        let uploadedImage = null;

        // ç”Ÿæˆæ‹ç«‹å¾—é£æ ¼è¾¹æ¡†
        function generatePolaroidCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 380;
            const ctx = canvas.getContext('2d');

            // ç™½è‰²è¾¹æ¡†ï¼ˆåªç”»è¾¹æ¡†ï¼Œä¸­é—´é€æ˜ï¼‰
            // ä¸Šè¾¹æ¡†
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 300, 15);
            // ä¸‹è¾¹æ¡†
            ctx.fillRect(0, 285, 300, 95);
            // å·¦è¾¹æ¡†
            ctx.fillRect(0, 0, 15, 380);
            // å³è¾¹æ¡†
            ctx.fillRect(285, 0, 15, 380);

            // è¾¹æ¡†å†…è¾¹çº¿ï¼ˆè£…é¥°ï¼‰
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.strokeRect(15, 15, 270, 270);

            // åº•éƒ¨æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â¤ï¸ INSTAX', 150, 345);

            return canvas.toDataURL('image/png');
        }

        // ç”Ÿæˆå¤å¤è¾¹æ¡†
        function generateVintageCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            // å¤å¤è¾¹æ¡†ï¼ˆåªç”»è¾¹æ¡†ï¼Œä¸­é—´é€æ˜ï¼‰
            ctx.strokeStyle = '#c9a66b';
            ctx.lineWidth = 15;
            ctx.strokeRect(10, 10, 300, 380);

            // å†…æ¡†
            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 3;
            ctx.strokeRect(28, 28, 264, 344);

            // å››è§’è£…é¥°
            const corners = [[10, 10], [310, 10], [310, 390], [10, 390]];
            ctx.fillStyle = '#c9a66b';
            corners.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
            });

            // è£…é¥°çº¿ï¼ˆè™šçº¿ï¼‰
            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(50, 50, 220, 300);
            ctx.setLineDash([]);

            return canvas.toDataURL('image/png');
        }

        // ç”Ÿæˆèƒ¶å·é£æ ¼è¾¹æ¡†
        function generateFilmCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 340;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');

            // èƒ¶å·å·¦è¾¹æ¡†ï¼ˆé»‘è‰²ï¼‰
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 20, 480);

            // èƒ¶å·å³è¾¹æ¡†ï¼ˆé»‘è‰²ï¼‰
            ctx.fillRect(320, 0, 20, 480);

            // ä¸Šä¸‹è¾¹æ¡†
            ctx.fillRect(0, 0, 340, 15);
            ctx.fillRect(0, 465, 340, 15);

            // å·¦å³é½¿å­”
            ctx.fillStyle = '#333';
            for (let y = 30; y < 480; y += 40) {
                ctx.fillRect(8, y, 12, 20);
                ctx.fillRect(320, y, 12, 20);
            }

            // è¾¹æ¡†çº¿
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 15, 300, 450);

            // è£…é¥°ç‚¹
            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.arc(170, 240, 5, 0, Math.PI * 2);
            ctx.fill();

            return canvas.toDataURL('image/png');
        }

        // é€‰æ‹©é¢„è®¾é€å¡
        presetCards.forEach(card => {
            card.addEventListener('click', () => {
                const preset = card.dataset.preset;
                
                // ç§»é™¤æ‰€æœ‰æ¿€æ´»çŠ¶æ€
                presetCards.forEach(c => c.classList.remove('active'));
                
                if (preset === 'custom') {
                    fileInput.click();
                    return;
                }
                
                // æ¿€æ´»å½“å‰é¢„è®¾
                card.classList.add('active');
                currentPreset = preset;
                
                // åŠ è½½é¢„è®¾é€å¡
                overlay.src = presets[preset];
                overlay.onload = () => {
                    console.log('é¢„è®¾é€å¡åŠ è½½æˆåŠŸï¼Œæ·»åŠ  visible ç±»');
                    overlay.classList.add('visible');
                    overlayLoaded = true;
                    baseWidth = overlay.naturalWidth;
                    baseHeight = overlay.naturalHeight;
                    initialScale = 1;
                    scale = 1;
                    rotation = 0;
                    scaleSlider.value = 100;
                    scaleValue.textContent = '100%';
                    rotateSlider.value = 0;
                    rotateValue.textContent = '0Â°';
                    updateOverlaySize();
                    resetPosition();
                };
            });
        });

        // çŠ¶æ€å˜é‡
        let overlayLoaded = false;
        let scale = 1;
        let initialScale = 1;
        let rotation = 0;
        let baseWidth = 0;
        let baseHeight = 0;
        let isDragging = false;
        let startX, startY, initialX, initialY;

        // åˆå§‹åŒ–ç›¸æœº
        async function initCamera() {
            try {
                console.log('æ­£åœ¨è¯·æ±‚ç›¸æœºæƒé™...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                console.log('ç›¸æœºæµè·å–æˆåŠŸ');
                video.srcObject = stream;

                // ç­‰å¾…è§†é¢‘å‡†å¤‡å¥½
                const waitForVideoReady = () => {
                    return new Promise((resolve, reject) => {
                        if (video.readyState >= 2) {
                            resolve();
                            return;
                        }
                        video.onloadedmetadata = () => {
                            console.log('è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ');
                            resolve();
                        };
                        video.onerror = reject;
                    });
                };

                await waitForVideoReady();

                console.log('å¼€å§‹æ’­æ”¾è§†é¢‘');
                await video.play();
                console.log('è§†é¢‘å¼€å§‹æ’­æ”¾');
                loading.classList.add('hidden');

            } catch (err) {
                console.error('Camera error:', err);
                loading.classList.add('hidden');
                document.getElementById('videoFallback').classList.add('active');
            }
        }

        // ä¸Šä¼ é€å¡
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('å·²é€‰æ‹©æ–‡ä»¶:', file.name, file.type, file.size);
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedImageData = event.target.result;
                    console.log('æ–‡ä»¶è¯»å–æˆåŠŸï¼Œæ•°æ®é•¿åº¦:', uploadedImageData.length);

                    uploadedImage = new Image();
                    uploadedImage.onload = () => {
                        console.log('å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œå°ºå¯¸:', uploadedImage.width, uploadedImage.height);
                        // æ¸…é™¤é¢„è®¾æ¿€æ´»çŠ¶æ€
                        presetCards.forEach(c => c.classList.remove('active'));

                        // æ˜¾ç¤ºèƒŒæ™¯ç§»é™¤å¼¹çª—
                        showBackgroundRemover(uploadedImage);
                    };
                    uploadedImage.onerror = () => {
                        console.error('å›¾ç‰‡åŠ è½½å¤±è´¥');
                        alert('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•');
                    };
                    uploadedImage.src = uploadedImageData;
                };
                reader.onerror = () => {
                    console.error('æ–‡ä»¶è¯»å–å¤±è´¥');
                    alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
                };
                reader.readAsDataURL(file);
            }
        });

        // æ˜¾ç¤ºèƒŒæ™¯ç§»é™¤å¼¹çª—
        function showBackgroundRemover(img) {
            console.log('æ˜¾ç¤ºèƒŒæ™¯ç§»é™¤å¼¹çª—', img.width, img.height);
            bgRemover.classList.add('active');

            // è®¾ç½®é¢„è§ˆç”»å¸ƒå°ºå¯¸
            const maxSize = 300;
            const scale = Math.min(maxSize / img.width, maxSize / img.height);
            const width = img.width * scale;
            const height = img.height * scale;

            originalPreview.width = width;
            originalPreview.height = height;
            processedPreview.width = width;
            processedPreview.height = height;

            // ç»˜åˆ¶åŸå§‹å›¾ç‰‡
            const origCtx = originalPreview.getContext('2d');
            origCtx.drawImage(img, 0, 0, width, height);

            // è‡ªåŠ¨æ£€æµ‹èƒŒæ™¯è‰²å¹¶å¤„ç†
            autoDetectBackgroundColor();
        }

        // è‡ªåŠ¨æ£€æµ‹èƒŒæ™¯è‰²
        function autoDetectBackgroundColor() {
            if (!uploadedImage) return;

            // ä½¿ç”¨åŸå›¾æ£€æµ‹
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = uploadedImage.width;
            tempCanvas.height = uploadedImage.height;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(uploadedImage, 0, 0);

            // é‡‡æ ·å››ä¸ªè§’å’Œè¾¹ç¼˜çš„é¢œè‰²
            const samplePoints = [
                [0, 0],
                [uploadedImage.width - 1, 0],
                [0, uploadedImage.height - 1],
                [uploadedImage.width - 1, uploadedImage.height - 1],
                [uploadedImage.width / 2, 0],
                [uploadedImage.width / 2, uploadedImage.height - 1]
            ];

            let totalR = 0, totalG = 0, totalB = 0;
            samplePoints.forEach(([x, y]) => {
                const pixel = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                totalR += pixel[0];
                totalG += pixel[1];
                totalB += pixel[2];
            });

            const avgR = Math.round(totalR / samplePoints.length);
            const avgG = Math.round(totalG / samplePoints.length);
            const avgB = Math.round(totalB / samplePoints.length);

            // è½¬æ¢ä¸ºåå…­è¿›åˆ¶
            const hex = '#' + [avgR, avgG, avgB].map(x => x.toString(16).padStart(2, '0')).join('');
            bgColorPicker.value = hex;

            console.log('è‡ªåŠ¨æ£€æµ‹åˆ°çš„èƒŒæ™¯è‰²:', hex);
            removeBackground();
        }

        // ç§»é™¤èƒŒæ™¯
        function removeBackground() {
            if (!uploadedImage) return;

            const ctx = processedPreview.getContext('2d');
            ctx.drawImage(uploadedImage, 0, 0, processedPreview.width, processedPreview.height);

            const imageData = ctx.getImageData(0, 0, processedPreview.width, processedPreview.height);
            const data = imageData.data;

            // è·å–è¦ç§»é™¤çš„èƒŒæ™¯è‰²
            const bgColor = hexToRgb(bgColorPicker.value);
            const tolerance = toleranceSlider.value / 100;
            const feather = parseInt(featherSlider.value);

            // åˆ›å»ºé€æ˜åº¦æ•°ç»„ç”¨äºç¾½åŒ–
            const alphaMap = new Uint8Array(data.length / 4);

            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // è®¡ç®—é¢œè‰²è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(r - bgColor.r, 2) +
                    Math.pow(g - bgColor.g, 2) +
                    Math.pow(b - bgColor.b, 2)
                );

                // æ ¹æ®å®¹å·®è®¡ç®—é€æ˜åº¦
                const maxDistance = Math.sqrt(255 * 255 + 255 * 255 + 255 * 255);
                const similarity = distance / maxDistance;

                if (similarity < tolerance) {
                    alphaMap[idx] = 0; // å®Œå…¨é€æ˜
                } else if (similarity < tolerance + 0.2) {
                    // è¿‡æ¸¡åŒºåŸŸï¼ˆè¾¹ç¼˜ç¾½åŒ–ï¼‰
                    alphaMap[idx] = Math.round(255 * (similarity - tolerance) / 0.2);
                } else {
                    alphaMap[idx] = 255; // å®Œå…¨ä¸é€æ˜
                }
            }

            // åº”ç”¨ç¾½åŒ–
            if (feather > 0) {
                const blurredAlpha = alphaMap.slice();
                for (let i = 0; i < alphaMap.length; i++) {
                    const x = i % processedPreview.width;
                    const y = Math.floor(i / processedPreview.width);

                    let sum = 0;
                    let count = 0;

                    // åœ¨ feather åŠå¾„å†…é‡‡æ ·
                    for (let dy = -feather; dy <= feather; dy++) {
                        for (let dx = -feather; dx <= feather; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < processedPreview.width &&
                                ny >= 0 && ny < processedPreview.height) {
                                const ni = ny * processedPreview.width + nx;
                                sum += alphaMap[ni];
                                count++;
                            }
                        }
                    }

                    blurredAlpha[i] = Math.round(sum / count);
                }

                // åº”ç”¨ç¾½åŒ–åçš„é€æ˜åº¦
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = blurredAlpha[i / 4];
                }
            } else {
                // ç›´æ¥åº”ç”¨é€æ˜åº¦
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = alphaMap[i / 4];
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // åå…­è¿›åˆ¶é¢œè‰²è½¬RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // å®¹å·®æ»‘å—å˜åŒ–
        toleranceSlider.addEventListener('input', (e) => {
            toleranceValue.textContent = e.target.value;
            removeBackground();
        });

        // ç¾½åŒ–æ»‘å—å˜åŒ–
        const featherSlider = document.getElementById('featherSlider');
        const featherValue = document.getElementById('featherValue');
        featherSlider.addEventListener('input', (e) => {
            featherValue.textContent = e.target.value;
            removeBackground();
        });

        // èƒŒæ™¯è‰²å˜åŒ–
        bgColorPicker.addEventListener('input', () => {
            removeBackground();
        });

        // è‡ªåŠ¨æ£€æµ‹æŒ‰é’®
        const autoDetectBtn = document.getElementById('autoDetectBtn');
        autoDetectBtn.addEventListener('click', () => {
            autoDetectBackgroundColor();
        });

        // åº”ç”¨å¤„ç†åçš„å›¾ç‰‡
        applyRemover.addEventListener('click', () => {
            // ä½¿ç”¨åŸå›¾å°ºå¯¸åˆ›å»ºæœ€ç»ˆé€æ˜å›¾ç‰‡
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = uploadedImage.width;
            finalCanvas.height = uploadedImage.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ç»˜åˆ¶åŸå›¾
            finalCtx.drawImage(uploadedImage, 0, 0);

            const imageData = finalCtx.getImageData(0, 0, finalCanvas.width, finalCanvas.height);
            const data = imageData.data;

            const bgColor = hexToRgb(bgColorPicker.value);
            const tolerance = toleranceSlider.value / 100;
            const feather = parseInt(featherSlider.value);

            // åˆ›å»ºé€æ˜åº¦æ•°ç»„ç”¨äºç¾½åŒ–
            const alphaMap = new Uint8Array(data.length / 4);

            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // è®¡ç®—é¢œè‰²è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(r - bgColor.r, 2) +
                    Math.pow(g - bgColor.g, 2) +
                    Math.pow(b - bgColor.b, 2)
                );

                // æ ¹æ®å®¹å·®è®¡ç®—é€æ˜åº¦
                const maxDistance = Math.sqrt(255 * 255 + 255 * 255 + 255 * 255);
                const similarity = distance / maxDistance;

                if (similarity < tolerance) {
                    alphaMap[idx] = 0;
                } else if (similarity < tolerance + 0.2) {
                    alphaMap[idx] = Math.round(255 * (similarity - tolerance) / 0.2);
                } else {
                    alphaMap[idx] = 255;
                }
            }

            // åº”ç”¨ç¾½åŒ–
            if (feather > 0) {
                const blurredAlpha = alphaMap.slice();
                for (let i = 0; i < alphaMap.length; i++) {
                    const x = i % finalCanvas.width;
                    const y = Math.floor(i / finalCanvas.width);

                    let sum = 0;
                    let count = 0;

                    for (let dy = -feather; dy <= feather; dy++) {
                        for (let dx = -feather; dx <= feather; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < finalCanvas.width &&
                                ny >= 0 && ny < finalCanvas.height) {
                                const ni = ny * finalCanvas.width + nx;
                                sum += alphaMap[ni];
                                count++;
                            }
                        }
                    }

                    blurredAlpha[i] = Math.round(sum / count);
                }

                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = blurredAlpha[i / 4];
                }
            } else {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = alphaMap[i / 4];
                }
            }

            finalCtx.putImageData(imageData, 0, 0);

            // è®¾ç½®ä¸ºé€å¡
            overlay.src = finalCanvas.toDataURL('image/png');
            overlay.onload = () => {
                overlay.classList.add('visible');
                overlayLoaded = true;
                baseWidth = overlay.naturalWidth;
                baseHeight = overlay.naturalHeight;
                initialScale = 1;
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            };

            bgRemover.classList.remove('active');
        });

        // è·³è¿‡èƒŒæ™¯ç§»é™¤
        const skipRemover = document.getElementById('skipRemover');
        skipRemover.addEventListener('click', () => {
            // ç›´æ¥ä½¿ç”¨åŸå›¾
            overlay.src = uploadedImageData;
            overlay.onload = () => {
                overlay.classList.add('visible');
                overlayLoaded = true;
                baseWidth = overlay.naturalWidth;
                baseHeight = overlay.naturalHeight;
                initialScale = 1;
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            };
            bgRemover.classList.remove('active');
        });

        // å–æ¶ˆèƒŒæ™¯ç§»é™¤ï¼ˆåŠŸèƒ½å·²é›†æˆåˆ° closeRemoverï¼‰
        // cancelRemover.addEventListener('click', () => {
        //     bgRemover.classList.remove('active');
        // });

        // å…³é—­èƒŒæ™¯ç§»é™¤å¼¹çª—
        closeRemover.addEventListener('click', () => {
            bgRemover.classList.remove('active');
        });

        // æ—‹è½¬æ§åˆ¶
        rotateSlider.addEventListener('input', (e) => {
            rotation = parseInt(e.target.value);
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        rotateLeftBtn.addEventListener('click', () => {
            rotation = Math.max(-180, rotation - 15);
            rotateSlider.value = rotation;
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        rotateRightBtn.addEventListener('click', () => {
            rotation = Math.min(180, rotation + 15);
            rotateSlider.value = rotation;
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        // æ›´æ–°é€å¡å˜æ¢ï¼ˆç¼©æ”¾+æ—‹è½¬ï¼‰
        function updateOverlayTransform() {
            if (overlayLoaded) {
                overlayWrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
            }
        }

        // é¢„è§ˆå¼¹çª—ç›¸å…³å…ƒç´ 
        const previewModal = document.getElementById('previewModal');
        const previewImage = document.getElementById('previewImage');
        const saveBtn = document.getElementById('saveBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        const closePreview = document.getElementById('closePreview');

        // æ‹ç…§é¢„è§ˆ
        let capturedImageData = null;

        function capturePhoto() {
            const ctx = canvas.getContext('2d');

            // æ£€æŸ¥æ˜¯å¦æœ‰è§†é¢‘æµ
            const hasVideo = video.srcObject && video.readyState >= 2;

            if (hasVideo) {
                // ä½¿ç”¨ç›¸æœºç”»é¢
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                const videoRect = video.getBoundingClientRect();
                const overlayRect = overlay.getBoundingClientRect();

                const scaleX = canvas.width / videoRect.width;
                const scaleY = canvas.height / videoRect.height;

                const overlayX = (overlayRect.left - videoRect.left) * scaleX;
                const overlayY = (overlayRect.top - videoRect.top) * scaleY;
                const overlayWidth = overlayRect.width * scaleX;
                const overlayHeight = overlayRect.height * scaleY;

                ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);
            } else {
                // ä½¿ç”¨æ¸å˜èƒŒæ™¯
                canvas.width = 1920;
                canvas.height = 1080;

                // ç»˜åˆ¶æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶é€å¡
                const fallbackRect = document.getElementById('videoFallback').getBoundingClientRect();
                const overlayRect = overlay.getBoundingClientRect();

                const scaleX = canvas.width / fallbackRect.width;
                const scaleY = canvas.height / fallbackRect.height;

                const overlayX = (overlayRect.left - fallbackRect.left) * scaleX;
                const overlayY = (overlayRect.top - fallbackRect.top) * scaleY;
                const overlayWidth = overlayRect.width * scaleX;
                const overlayHeight = overlayRect.height * scaleY;

                ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);
            }

            // ä¿å­˜å›¾ç‰‡æ•°æ®ç”¨äºé¢„è§ˆ
            capturedImageData = canvas.toDataURL('image/png');
            previewImage.src = capturedImageData;
            previewModal.classList.add('active');
        }

        // ä¿å­˜ç…§ç‰‡
        saveBtn.addEventListener('click', () => {
            if (capturedImageData) {
                const link = document.createElement('a');
                link.download = `é€å¡ç…§ç‰‡_${Date.now()}.png`;
                link.href = capturedImageData;
                link.click();
            }
        });

        // é‡æ‹
        retakeBtn.addEventListener('click', () => {
            previewModal.classList.remove('active');
            capturedImageData = null;
        });

        // å…³é—­é¢„è§ˆ
        closePreview.addEventListener('click', () => {
            previewModal.classList.remove('active');
            capturedImageData = null;
        });

        // æ›´æ–°é€å¡å¤§å°
        function updateOverlaySize() {
            const containerWidth = window.innerWidth * 0.8;
            const containerHeight = window.innerHeight * 0.8;
            
            const aspectRatio = baseWidth / baseHeight;
            let newWidth, newHeight;
            
            if (aspectRatio > containerWidth / containerHeight) {
                newWidth = containerWidth;
                newHeight = containerWidth / aspectRatio;
            } else {
                newHeight = containerHeight;
                newWidth = containerHeight * aspectRatio;
            }
            
            overlay.style.width = (newWidth * scale) + 'px';
            overlay.style.height = (newHeight * scale) + 'px';
        }

        // æ»‘åŠ¨æ¡æ§åˆ¶ç¼©æ”¾
        scaleSlider.addEventListener('input', (e) => {
            scale = e.target.value / 100;
            scaleValue.textContent = e.target.value + '%';
            if (overlayLoaded) {
                updateOverlaySize();
            }
        });

        // é‡ç½®ä½ç½®
        function resetPosition() {
            overlayWrapper.style.left = '50%';
            overlayWrapper.style.top = '50%';
            overlayWrapper.style.transform = 'translate(-50%, -50%) rotate(0deg)';
        }

        resetBtn.addEventListener('click', () => {
            if (overlayLoaded) {
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            }
        });

        // æ‹–æ‹½åŠŸèƒ½
        overlayWrapper.addEventListener('mousedown', startDrag);
        overlayWrapper.addEventListener('touchstart', startDrag, { passive: false });

        function startDrag(e) {
            if (!overlayLoaded) return;
            e.preventDefault();
            isDragging = true;
            
            const point = e.touches ? e.touches[0] : e;
            startX = point.clientX;
            startY = point.clientY;
            
            const rect = overlayWrapper.getBoundingClientRect();
            initialX = rect.left + rect.width / 2;
            initialY = rect.top + rect.height / 2;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();

            const point = e.touches ? e.touches[0] : e;
            const dx = point.clientX - startX;
            const dy = point.clientY - startY;

            const newX = initialX + dx;
            const newY = initialY + dy;

            overlayWrapper.style.left = newX + 'px';
            overlayWrapper.style.top = newY + 'px';
            overlayWrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
        }

        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // åŒæŒ‡ç¼©æ”¾å’Œæ—‹è½¬
        let initialDistance = 0;
        let initialAngle = 0;
        let initialRotation = 0;

        overlayWrapper.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2 && overlayLoaded) {
                e.preventDefault();
                initialDistance = getDistance(e.touches);
                initialAngle = getAngle(e.touches);
                initialScale = scale;
                initialRotation = rotation;
            }
        }, { passive: false });

        overlayWrapper.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && overlayLoaded) {
                e.preventDefault();
                const currentDistance = getDistance(e.touches);
                const currentAngle = getAngle(e.touches);

                // è®¡ç®—ç¼©æ”¾
                const scaleFactor = currentDistance / initialDistance;
                scale = Math.min(2, Math.max(0.2, initialScale * scaleFactor));
                scaleSlider.value = Math.round(scale * 100);
                scaleValue.textContent = scaleSlider.value + '%';

                // è®¡ç®—æ—‹è½¬ï¼ˆè§’åº¦å·®ï¼‰
                const angleDiff = currentAngle - initialAngle;
                rotation = initialRotation + angleDiff;

                // é™åˆ¶æ—‹è½¬è§’åº¦åœ¨ -180 åˆ° 180 ä¹‹é—´
                while (rotation > 180) rotation -= 360;
                while (rotation < -180) rotation += 360;

                rotateSlider.value = Math.round(rotation);
                rotateValue.textContent = Math.round(rotation) + 'Â°';

                updateOverlaySize();
                updateOverlayTransform();

                initialDistance = currentDistance;
                initialAngle = currentAngle;
            }
        }, { passive: false });

        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAngle(touches) {
            const dx = touches[1].clientX - touches[0].clientX;
            const dy = touches[1].clientY - touches[0].clientY;
            return Math.atan2(dy, dx) * (180 / Math.PI);
        }

        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        overlayWrapper.addEventListener('wheel', (e) => {
            if (!overlayLoaded) return;
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.min(2, Math.max(0.2, scale * delta));
            scaleSlider.value = Math.round(scale * 100);
            scaleValue.textContent = scaleSlider.value + '%';

            updateOverlaySize();
        }, { passive: false });

        // æ‹ç…§ä¿å­˜
        captureBtn.addEventListener('click', () => {
            if (!overlayLoaded) {
                alert('è¯·å…ˆä¸Šä¼ é€å¡');
                return;
            }

            capturePhoto();
        });

        // çª—å£å¤§å°å˜åŒ–æ—¶æ›´æ–°é€å¡
        window.addEventListener('resize', () => {
            if (overlayLoaded) {
                updateOverlaySize();
            }
        });

        // å¯åŠ¨åº”ç”¨
        initCamera();
        
        // è°ƒè¯•æŒ‰é’®
        const debugBtn = document.getElementById('debugBtn');
        debugBtn.addEventListener('click', () => {
            const overlayRect = overlay.getBoundingClientRect();
            const overlayWrapperRect = overlayWrapper.getBoundingClientRect();
            const info = `
è°ƒè¯•ä¿¡æ¯ï¼š
- overlayLoaded: ${overlayLoaded}
- overlay.src: ${overlay.src ? (overlay.src.length > 50 ? overlay.src.substring(0, 50) + '...' : overlay.src) : 'empty'}
- overlay.hidden: ${overlay.classList.contains('hidden')}
- overlay width/height: ${overlay.width} / ${overlay.height}
- overlay naturalWidth/naturalHeight: ${overlay.naturalWidth} / ${overlay.naturalHeight}
- overlay offsetWidth/offsetHeight: ${overlay.offsetWidth} / ${overlay.offsetHeight}
- overlay.offsetWidth æ˜¯å¦ä¸º0: ${overlay.offsetWidth === 0}
- overlay display: ${window.getComputedStyle(overlay).display}
- overlay visibility: ${window.getComputedStyle(overlay).visibility}
- overlay opacity: ${window.getComputedStyle(overlay).opacity}
- overlay z-index: ${window.getComputedStyle(overlay).zIndex}
- overlay-wrapper display: ${window.getComputedStyle(overlayWrapper).display}
- overlay-wrapper z-index: ${window.getComputedStyle(overlayWrapper).zIndex}
- overlayRect: ${JSON.stringify({
    width: overlayRect.width,
    height: overlayRect.height,
    left: overlayRect.left,
    top: overlayRect.top
})}
- overlayWrapperRect: ${JSON.stringify({
    width: overlayWrapperRect.width,
    height: overlayWrapperRect.height,
    left: overlayWrapperRect.left,
    top: overlayWrapperRect.top
})}
            `;
            alert(info);
            console.log(info);
        });
    </script>
</body>
</html>
