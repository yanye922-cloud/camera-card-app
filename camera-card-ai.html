<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sentu é¡¿ - çµå½±ç›¸æœº v3.0 AIç‰ˆ</title>
    <script type="module">
        import imgly from 'https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.2/dist/index.esm.js';
        window.imglyRemoveBackground = imgly;
    </script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        #video.hidden {
            display: none;
        }

        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none;
        }

        #outputCanvas.visible {
            display: block;
        }

        #outputCanvas.hidden {
            display: none;
        }

        .video-fallback {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            align-items: center;
            justify-content: center;
        }

        .video-fallback.active {
            display: flex;
        }

        .video-fallback-text {
            color: white;
            font-size: 18px;
            text-align: center;
            padding: 20px;
        }

        #overlay {
            position: relative;
            max-width: 80vw;
            max-height: 80vh;
            pointer-events: none;
            display: none;
        }

        #overlay.visible {
            display: block;
        }

        .overlay-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            cursor: move;
            touch-action: none;
            z-index: 50;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px 20px 0 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
        }

        .slider-container label {
            color: white;
            font-size: 14px;
            white-space: nowrap;
        }

        #scaleSlider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        #scaleSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .button-row {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        button {
            padding: 14px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            -webkit-transition: transform 0.2s, opacity 0.2s;
        }

        #rotateSlider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        #rotateSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: scale(0.95);
            -webkit-transform: scale(0.95);
        }

        #uploadBtn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            flex: 1;
        }

        #captureBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        #resetBtn {
            background: rgba(255, 107, 107, 0.9);
            color: white;
            padding: 14px;
        }

        .hidden {
            display: none !important;
        }

        #fileInput {
            display: none;
        }

        .tip {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            padding: 0 10px;
        }

        /* æ¨¡å‹åŠ è½½çŠ¶æ€æç¤º */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            transition: opacity 0.5s;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-text {
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }

        .preset-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            padding: 0 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .preset-card {
            flex-shrink: 0;
            width: 70px;
            height: 70px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
        }

        .preset-card:hover, .preset-card.active {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.3);
            transform: scale(1.1);
        }

        .preset-card-label {
            font-size: 10px;
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* é¢„è§ˆå¼¹çª—æ ·å¼ */
        .preview-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 20px;
            z-index: 400;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .preview-modal.active {
            display: block;
        }

        .preview-modal h3 {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .preview-modal img {
            max-width: 100%;
            max-height: 70vh;
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
        }

        .preview-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .preview-buttons button {
            padding: 12px 30px;
            font-size: 14px;
        }

        .close-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }

        /* AIè®¾ç½®é¢æ¿ */
        .ai-settings {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 10px;
        }

        .ai-settings h4 {
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .setting-row label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            min-width: 85px;
            font-weight: 500;
        }

        .toggle-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 18px;
            border-radius: 18px;
            font-size: 13px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: all 0.2s;
            -webkit-transition: all 0.2s;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.02);
            -webkit-transform: scale(1.02);
        }

        .toggle-btn:active {
            transform: scale(0.98);
            -webkit-transform: scale(0.98);
        }

        .toggle-btn.active {
            background: rgba(102, 126, 234, 0.9);
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            -webkit-box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        /* é¢œè‰²æŠ å›¾å¼¹çª— */
        .color-remover-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 20px;
            z-index: 300;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .color-remover-modal.active {
            display: block;
        }

        .color-remover-modal h3 {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .color-preview-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .color-preview-box {
            text-align: center;
        }

        .color-preview-box canvas {
            max-width: 150px;
            max-height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .color-preview-box p {
            color: white;
            font-size: 12px;
            margin-top: 8px;
        }

        .color-remover-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .close-color-remover {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }

        /* AIæŠ å›¾é¢„è§ˆå¼¹çª— */
        .ai-remover-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 20px;
            z-index: 300;
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .ai-remover-modal.active {
            display: block;
        }

        .ai-remover-modal h3 {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .ai-preview-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .ai-preview-box {
            text-align: center;
        }

        .ai-preview-box canvas {
            max-width: 150px;
            max-height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 10px 10px;
        }

        .ai-preview-box p {
            color: white;
            font-size: 12px;
            margin-top: 8px;
        }

        .ai-remover-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .close-ai-remover {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }

        /* æ¨¡å‹åŠ è½½æç¤º */
        .model-loading {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 229, 255, 0.2);
            border: 1px solid #00e5ff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            color: #00e5ff;
            z-index: 60;
            display: none;
        }

        .model-loading.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</div>
    </div>

    <div class="model-loading" id="model-loading">
        æ­£åœ¨åŠ è½½ AI æ¨¡å‹...
    </div>

    <div class="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="outputCanvas"></canvas>
        <div class="video-fallback" id="videoFallback">
            <div class="video-fallback-text">
                <p>ç›¸æœºä¸å¯ç”¨</p>
                <p style="font-size: 14px; margin-top: 10px;">ä½¿ç”¨æ¸å˜èƒŒæ™¯ä½œä¸ºé¢„è§ˆ</p>
            </div>
        </div>
        <div class="overlay-wrapper" id="overlayWrapper">
            <img id="overlay" src="" alt="">
        </div>
    </div>

    <div class="controls">
        <!-- AIè®¾ç½® -->
        <div class="ai-settings">
            <h4>ğŸ¤– AI èƒŒæ™¯ç§»é™¤è®¾ç½®</h4>
            <div class="setting-row">
                <button id="toggleAI" class="toggle-btn active">AIæŠ å›¾: å¼€å¯</button>
                <button id="toggleColor" class="toggle-btn">é¢œè‰²æŠ å›¾</button>
            </div>
        </div>

        <div class="slider-container">
            <label>ç¼©æ”¾:</label>
            <input type="range" id="scaleSlider" min="20" max="200" value="100">
            <label id="scaleValue">100%</label>
        </div>
        
        <div class="preset-selector">
            <div class="preset-card" data-preset="polaroid">
                <div>ğŸ“·</div>
                <div class="preset-card-label">æ‹ç«‹å¾—</div>
            </div>
            <div class="preset-card" data-preset="vintage">
                <div>ğŸï¸</div>
                <div class="preset-card-label">å¤å¤</div>
            </div>
            <div class="preset-card" data-preset="film">
                <div>ğŸ¬</div>
                <div class="preset-card-label">èƒ¶å·</div>
            </div>
            <div class="preset-card" data-preset="custom">
                <div>â•</div>
                <div class="preset-card-label">è‡ªå®šä¹‰</div>
            </div>
        </div>
        
        <div class="tip">æ‹–æ‹½è°ƒæ•´ä½ç½® Â· åŒæŒ‡ç¼©æ”¾æˆ–æ»‘åŠ¨æ¡è°ƒæ•´å¤§å°</div>

        <div class="slider-container">
            <label>æ—‹è½¬:</label>
            <button id="rotateLeftBtn" style="padding: 8px 12px; font-size: 14px;">â†º</button>
            <input type="range" id="rotateSlider" min="-180" max="180" value="0" style="flex: 1;">
            <button id="rotateRightBtn" style="padding: 8px 12px; font-size: 14px;">â†»</button>
            <label id="rotateValue">0Â°</label>
        </div>

        <div class="button-row">
            <button id="uploadBtn">ğŸ“· ä¸Šä¼ é€å¡</button>
            <button id="captureBtn">ğŸ“¸ æ‹ç…§ä¿å­˜</button>
            <button id="resetBtn">â†»</button>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/png,image/*">
    <canvas id="canvas" class="hidden"></canvas>

    <!-- é¢œè‰²æŠ å›¾å¼¹çª— -->
    <div class="color-remover-modal" id="colorRemoverModal">
        <button class="close-color-remover" id="closeColorRemover">Ã—</button>
        <h3>ğŸ¨ é¢œè‰²æŠ å›¾</h3>
        
        <div class="color-preview-container">
            <div class="color-preview-box">
                <canvas id="colorOriginalPreview"></canvas>
                <p>åŸå§‹å›¾ç‰‡</p>
            </div>
            <div class="color-preview-box">
                <canvas id="colorProcessedPreview"></canvas>
                <p>é¢„è§ˆæ•ˆæœ</p>
            </div>
        </div>

        <div style="margin: 20px 0;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label style="color: white; font-size: 14px;">èƒŒæ™¯è‰²:</label>
                <input type="color" id="colorBgColorPicker" value="#ffffff" style="width: 50px; height: 50px; border: none; border-radius: 8px; cursor: pointer;">
                <button id="colorAutoDetectBtn" style="background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 16px; font-size: 12px;">ğŸ” è‡ªåŠ¨æ£€æµ‹</button>
            </div>

            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label style="color: white; font-size: 14px;">å®¹å·®:</label>
                <input type="range" id="colorToleranceSlider" min="0" max="100" value="30" style="flex: 1;">
                <span style="color: white; font-size: 12px;" id="colorToleranceValue">30</span>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: white; font-size: 14px;">ç¾½åŒ–:</label>
                <input type="range" id="colorFeatherSlider" min="0" max="20" value="3" style="flex: 1;">
                <span style="color: white; font-size: 12px;" id="colorFeatherValue">3</span>
            </div>
        </div>

        <div class="color-remover-buttons">
            <button id="applyColorRemover" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 30px; font-size: 14px;">åº”ç”¨</button>
            <button id="skipColorRemover" style="background: rgba(255, 255, 255, 0.3); color: white; padding: 12px 30px; font-size: 14px;">è·³è¿‡</button>
        </div>
    </div>

    <!-- AIæŠ å›¾é¢„è§ˆå¼¹çª— -->
    <div class="ai-remover-modal" id="aiRemoverModal">
        <button class="close-ai-remover" id="closeAIRemover">Ã—</button>
        <h3>ğŸ¤– AI æŠ å›¾é¢„è§ˆ</h3>
        
        <div class="ai-preview-container">
            <div class="ai-preview-box">
                <canvas id="aiOriginalPreview"></canvas>
                <p>åŸå§‹å›¾ç‰‡</p>
            </div>
            <div class="ai-preview-box">
                <canvas id="aiProcessedPreview"></canvas>
                <p>AIæŠ å›¾æ•ˆæœ</p>
            </div>
        </div>

        <div class="setting-row" style="margin-top: 15px;">
            <p style="color: rgba(255,255,255,0.7); font-size: 12px; text-align: center; width: 100%;">
                ğŸ’¡ ä½¿ç”¨ imgly çš„é«˜ç²¾åº¦ AI èƒŒæ™¯ç§»é™¤æŠ€æœ¯
            </p>
        </div>

        <div class="ai-remover-buttons">
            <button id="applyAIRemover" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 30px; font-size: 14px;">åº”ç”¨</button>
            <button id="skipAIRemover" style="background: rgba(255, 255, 255, 0.3); color: white; padding: 12px 30px; font-size: 14px;">ä½¿ç”¨åŸå›¾</button>
        </div>
    </div>

    <!-- é¢„è§ˆå¼¹çª— -->
    <div class="preview-modal" id="previewModal">
        <button class="close-preview" id="closePreview">Ã—</button>
        <h3>ğŸ“¸ ç…§ç‰‡é¢„è§ˆ</h3>
        <img id="previewImage" src="" alt="é¢„è§ˆå›¾ç‰‡">
        <div class="preview-buttons">
            <button id="saveBtn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">ğŸ’¾ ä¿å­˜ç…§ç‰‡</button>
            <button id="retakeBtn" style="background: rgba(255, 107, 107, 0.9); color: white;">ğŸ”„ é‡æ‹</button>
        </div>
    </div>

    <script>
        // DOM å…ƒç´ 
        const video = document.getElementById('video');
        const outputCanvas = document.getElementById('outputCanvas');
        const overlay = document.getElementById('overlay');
        const overlayWrapper = document.getElementById('overlayWrapper');
        const uploadBtn = document.getElementById('uploadBtn');
        const captureBtn = document.getElementById('captureBtn');
        const resetBtn = document.getElementById('resetBtn');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');
        const rotateSlider = document.getElementById('rotateSlider');
        const rotateValue = document.getElementById('rotateValue');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const presetCards = document.querySelectorAll('.preset-card');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const modelLoading = document.getElementById('model-loading');

        // AIè®¾ç½®
        const toggleAI = document.getElementById('toggleAI');
        const toggleColor = document.getElementById('toggleColor');

        // é¢œè‰²æŠ å›¾å…ƒç´ 
        const colorRemoverModal = document.getElementById('colorRemoverModal');
        const closeColorRemover = document.getElementById('closeColorRemover');
        const colorOriginalPreview = document.getElementById('colorOriginalPreview');
        const colorProcessedPreview = document.getElementById('colorProcessedPreview');
        const colorBgColorPicker = document.getElementById('colorBgColorPicker');
        const colorToleranceSlider = document.getElementById('colorToleranceSlider');
        const colorToleranceValue = document.getElementById('colorToleranceValue');
        const colorFeatherSlider = document.getElementById('colorFeatherSlider');
        const colorFeatherValue = document.getElementById('colorFeatherValue');
        const applyColorRemover = document.getElementById('applyColorRemover');
        const skipColorRemover = document.getElementById('skipColorRemover');
        const colorAutoDetectBtn = document.getElementById('colorAutoDetectBtn');

        // AIæŠ å›¾å…ƒç´ 
        const aiRemoverModal = document.getElementById('aiRemoverModal');
        const closeAIRemover = document.getElementById('closeAIRemover');
        const aiOriginalPreview = document.getElementById('aiOriginalPreview');
        const aiProcessedPreview = document.getElementById('aiProcessedPreview');
        const applyAIRemover = document.getElementById('applyAIRemover');
        const skipAIRemover = document.getElementById('skipAIRemover');

        // é¢„è§ˆå¼¹çª—å…ƒç´ 
        const previewModal = document.getElementById('previewModal');
        const previewImage = document.getElementById('previewImage');
        const saveBtn = document.getElementById('saveBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        const closePreview = document.getElementById('closePreview');

        // å…¨å±€å˜é‡
        let isAIEnabled = true;
        let isProcessing = false;
        let uploadedImage = null;
        let uploadedImageData = null;
        let currentPreset = null;
        let overlayLoaded = false;
        let scale = 1;
        let rotation = 0;
        let baseWidth = 0;
        let baseHeight = 0;
        let isDragging = false;
        let startX, startY, initialX, initialY;
        let capturedImageData = null;
        let isModelLoaded = false;
        let processedVideoBlob = null;

        // é¢„è®¾é€å¡
        const presets = {
            polaroid: generatePolaroidCard(),
            vintage: generateVintageCard(),
            film: generateFilmCard()
        };

        // ç”Ÿæˆæ‹ç«‹å¾—é£æ ¼è¾¹æ¡†
        function generatePolaroidCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 380;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 300, 15);
            ctx.fillRect(0, 285, 300, 95);
            ctx.fillRect(0, 0, 15, 380);
            ctx.fillRect(285, 0, 15, 380);

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.strokeRect(15, 15, 270, 270);

            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â¤ï¸ INSTAX', 150, 345);

            return canvas.toDataURL('image/png');
        }

        // ç”Ÿæˆå¤å¤è¾¹æ¡†
        function generateVintageCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            ctx.strokeStyle = '#c9a66b';
            ctx.lineWidth = 15;
            ctx.strokeRect(10, 10, 300, 380);

            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 3;
            ctx.strokeRect(28, 28, 264, 344);

            const corners = [[10, 10], [310, 10], [310, 390], [10, 390]];
            ctx.fillStyle = '#c9a66b';
            corners.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(50, 50, 220, 300);
            ctx.setLineDash([]);

            return canvas.toDataURL('image/png');
        }

        // ç”Ÿæˆèƒ¶å·é£æ ¼è¾¹æ¡†
        function generateFilmCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 340;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 20, 480);
            ctx.fillRect(320, 0, 20, 480);
            ctx.fillRect(0, 0, 340, 15);
            ctx.fillRect(0, 465, 340, 15);

            ctx.fillStyle = '#333';
            for (let y = 30; y < 480; y += 40) {
                ctx.fillRect(8, y, 12, 20);
                ctx.fillRect(320, y, 12, 20);
            }

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 15, 300, 450);

            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.arc(170, 240, 5, 0, Math.PI * 2);
            ctx.fill();

            return canvas.toDataURL('image/png');
        }

        // åˆå§‹åŒ–ç›¸æœº
        async function initCamera() {
            try {
                console.log('æ­£åœ¨è¯·æ±‚ç›¸æœºæƒé™...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                video.srcObject = stream;

                const waitForVideoReady = () => {
                    return new Promise((resolve, reject) => {
                        if (video.readyState >= 2) {
                            resolve();
                            return;
                        }
                        video.onloadedmetadata = () => {
                            console.log('è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ');
                            resolve();
                        };
                        video.onerror = reject;
                    });
                };

                await waitForVideoReady();
                await video.play();
                console.log('è§†é¢‘å¼€å§‹æ’­æ”¾');

                // éšè—åŠ è½½é®ç½©
                loadingOverlay.style.opacity = '0';
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500);

            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('videoFallback').classList.add('active');
                loadingOverlay.style.display = 'none';
            }
        }

        // AIèƒŒæ™¯ç§»é™¤å¤„ç†
        async function removeBackground(imageBlob) {
            try {
                const config = {
                    publicPath: "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.2/dist/",
                    debug: false,
                    proxyToWorker: true,
                    model: 'isnet-general-use',
                };
                
                const resultBlob = await window.imglyRemoveBackground(imageBlob, config);
                return resultBlob;
            } catch (error) {
                console.error('AIèƒŒæ™¯ç§»é™¤å¤±è´¥:', error);
                throw error;
            }
        }

        // AI/é¢œè‰²æŠ å›¾åˆ‡æ¢
        toggleAI.addEventListener('click', () => {
            isAIEnabled = true;
            updateToggleButtons();
            
            if (isAIEnabled) {
                outputCanvas.classList.remove('hidden');
                outputCanvas.classList.add('visible');
                video.classList.add('hidden');
                console.log('åˆ‡æ¢åˆ° imgly AI æŠ å›¾æ¨¡å¼');
            }
        });

        toggleColor.addEventListener('click', () => {
            isAIEnabled = false;
            updateToggleButtons();
            
            if (!isAIEnabled) {
                outputCanvas.classList.add('hidden');
                outputCanvas.classList.remove('visible');
                video.classList.remove('hidden');
                console.log('åˆ‡æ¢åˆ°é¢œè‰²æŠ å›¾æ¨¡å¼');
            }
        });

        function updateToggleButtons() {
            toggleAI.classList.toggle('active', isAIEnabled);
            toggleColor.classList.toggle('active', !isAIEnabled);
            toggleAI.textContent = isAIEnabled ? 'AIæŠ å›¾: å¼€å¯' : 'AIæŠ å›¾';
            toggleColor.textContent = !isAIEnabled ? 'é¢œè‰²æŠ å›¾: å¼€å¯' : 'é¢œè‰²æŠ å›¾';
        }

        // é€‰æ‹©é¢„è®¾é€å¡
        presetCards.forEach(card => {
            card.addEventListener('click', () => {
                const preset = card.dataset.preset;
                
                presetCards.forEach(c => c.classList.remove('active'));
                
                if (preset === 'custom') {
                    fileInput.click();
                    return;
                }
                
                card.classList.add('active');
                currentPreset = preset;
                
                overlay.src = presets[preset];
                overlay.onload = () => {
                    overlay.classList.add('visible');
                    overlayLoaded = true;
                    baseWidth = overlay.naturalWidth;
                    baseHeight = overlay.naturalHeight;
                    scale = 1;
                    rotation = 0;
                    scaleSlider.value = 100;
                    scaleValue.textContent = '100%';
                    rotateSlider.value = 0;
                    rotateValue.textContent = '0Â°';
                    updateOverlaySize();
                    resetPosition();
                };
            });
        });

        // ä¸Šä¼ é€å¡
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedImageData = event.target.result;
                    uploadedImage = new Image();
                    uploadedImage.onload = () => {
                        presetCards.forEach(c => c.classList.remove('active'));
                        
                        if (isAIEnabled) {
                            showAIRemover();
                        } else {
                            showColorRemover();
                        }
                    };
                    uploadedImage.src = uploadedImageData;
                };
                reader.readAsDataURL(file);
            }
        });

        // æ˜¾ç¤º AI æŠ å›¾é¢„è§ˆå¼¹çª—
        function showAIRemover() {
            aiRemoverModal.classList.add('active');

            const maxSize = 300;
            const scale = Math.min(maxSize / uploadedImage.width, maxSize / uploadedImage.height);
            const width = uploadedImage.width * scale;
            const height = uploadedImage.height * scale;

            aiOriginalPreview.width = width;
            aiOriginalPreview.height = height;
            aiProcessedPreview.width = width;
            aiProcessedPreview.height = height;

            // ç»˜åˆ¶åŸå›¾
            const origCtx = aiOriginalPreview.getContext('2d');
            origCtx.drawImage(uploadedImage, 0, 0, width, height);

            // å¤„ç† AI æŠ å›¾
            processAIRemover();
        }

        // å¤„ç† AI æŠ å›¾
        async function processAIRemover() {
            if (!uploadedImage) return;

            const width = aiProcessedPreview.width;
            const height = aiProcessedPreview.height;

            // å°†å›¾ç‰‡è½¬ä¸º Blob
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = uploadedImage.width;
            tempCanvas.height = uploadedImage.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(uploadedImage, 0, 0);

            tempCanvas.toBlob(async (blob) => {
                try {
                    modelLoading.classList.add('visible');
                    
                    const resultBlob = await removeBackground(blob);
                    modelLoading.classList.remove('visible');

                    // æ˜¾ç¤ºç»“æœ
                    const previewCtx = aiProcessedPreview.getContext('2d');
                    const resultImage = new Image();
                    resultImage.onload = () => {
                        previewCtx.clearRect(0, 0, width, height);
                        previewCtx.drawImage(resultImage, 0, 0, width, height);
                    };
                    resultImage.src = URL.createObjectURL(resultBlob);
                } catch (error) {
                    console.error('AIå¤„ç†å¤±è´¥:', error);
                    modelLoading.classList.remove('visible');
                    alert('AIå¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•æˆ–åˆ‡æ¢åˆ°é¢œè‰²æŠ å›¾æ¨¡å¼');
                    
                    // æ˜¾ç¤ºåŸå›¾
                    const previewCtx = aiProcessedPreview.getContext('2d');
                    previewCtx.drawImage(uploadedImage, 0, 0, width, height);
                }
            }, 'image/png');
        }

        // AIæŠ å›¾å¼¹çª—äº‹ä»¶
        applyAIRemover.addEventListener('click', () => {
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.opacity = '1';
            loadingText.textContent = 'æ­£åœ¨ AI æŠ å›¾ä¸­...';

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = uploadedImage.width;
            tempCanvas.height = uploadedImage.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(uploadedImage, 0, 0);

            tempCanvas.toBlob(async (blob) => {
                try {
                    const resultBlob = await removeBackground(blob);
                    const url = URL.createObjectURL(resultBlob);
                    
                    overlay.src = url;
                    overlay.onload = () => {
                        overlay.classList.add('visible');
                        overlayLoaded = true;
                        baseWidth = overlay.naturalWidth;
                        baseHeight = overlay.naturalHeight;
                        scale = 1;
                        rotation = 0;
                        scaleSlider.value = 100;
                        scaleValue.textContent = '100%';
                        rotateSlider.value = 0;
                        rotateValue.textContent = '0Â°';
                        updateOverlaySize();
                        resetPosition();
                        
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 500);
                    };

                    aiRemoverModal.classList.remove('active');
                } catch (error) {
                    console.error('AI å¤„ç†å¤±è´¥:', error);
                    loadingOverlay.style.display = 'none';
                    alert('AI å¤„ç†å¤±è´¥ï¼Œå·²ä½¿ç”¨åŸå›¾');
                    
                    overlay.src = uploadedImageData;
                    overlay.onload = () => {
                        overlay.classList.add('visible');
                        overlayLoaded = true;
                        baseWidth = overlay.naturalWidth;
                        baseHeight = overlay.naturalHeight;
                        scale = 1;
                        rotation = 0;
                        scaleSlider.value = 100;
                        scaleValue.textContent = '100%';
                        rotateSlider.value = 0;
                        rotateValue.textContent = '0Â°';
                        updateOverlaySize();
                        resetPosition();
                    };
                    aiRemoverModal.classList.remove('active');
                }
            }, 'image/png');
        });

        skipAIRemover.addEventListener('click', () => {
            overlay.src = uploadedImageData;
            overlay.onload = () => {
                overlay.classList.add('visible');
                overlayLoaded = true;
                baseWidth = overlay.naturalWidth;
                baseHeight = overlay.naturalHeight;
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            };
            aiRemoverModal.classList.remove('active');
        });

        closeAIRemover.addEventListener('click', () => {
            aiRemoverModal.classList.remove('active');
        });

        // æ˜¾ç¤ºé¢œè‰²æŠ å›¾å¼¹çª—
        function showColorRemover() {
            colorRemoverModal.classList.add('active');

            const maxSize = 300;
            const scale = Math.min(maxSize / uploadedImage.width, maxSize / uploadedImage.height);
            const width = uploadedImage.width * scale;
            const height = uploadedImage.height * scale;

            colorOriginalPreview.width = width;
            colorOriginalPreview.height = height;
            colorProcessedPreview.width = width;
            colorProcessedPreview.height = height;

            const origCtx = colorOriginalPreview.getContext('2d');
            origCtx.drawImage(uploadedImage, 0, 0, width, height);

            autoDetectBackgroundColor();
            processColorRemover();
        }

        // è‡ªåŠ¨æ£€æµ‹èƒŒæ™¯è‰²
        function autoDetectBackgroundColor() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = uploadedImage.width;
            tempCanvas.height = uploadedImage.height;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(uploadedImage, 0, 0);

            const samplePoints = [
                [0, 0],
                [uploadedImage.width - 1, 0],
                [0, uploadedImage.height - 1],
                [uploadedImage.width - 1, uploadedImage.height - 1],
                [uploadedImage.width / 2, 0],
                [uploadedImage.width / 2, uploadedImage.height - 1]
            ];

            let totalR = 0, totalG = 0, totalB = 0;
            samplePoints.forEach(([x, y]) => {
                const pixel = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                totalR += pixel[0];
                totalG += pixel[1];
                totalB += pixel[2];
            });

            const avgR = Math.round(totalR / samplePoints.length);
            const avgG = Math.round(totalG / samplePoints.length);
            const avgB = Math.round(totalB / samplePoints.length);
            const hex = '#' + [avgR, avgG, avgB].map(x => x.toString(16).padStart(2, '0')).join('');
            colorBgColorPicker.value = hex;
        }

        // å¤„ç†é¢œè‰²æŠ å›¾
        function processColorRemover() {
            const ctx = colorProcessedPreview.getContext('2d');
            ctx.drawImage(uploadedImage, 0, 0, colorProcessedPreview.width, colorProcessedPreview.height);

            const imageData = ctx.getImageData(0, 0, colorProcessedPreview.width, colorProcessedPreview.height);
            const data = imageData.data;
            const bgColor = hexToRgb(colorBgColorPicker.value);
            const tolerance = parseInt(colorToleranceSlider.value);
            const feather = parseInt(colorFeatherSlider.value);

            const alphaMap = new Uint8Array(data.length / 4);

            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                const distance = Math.sqrt(
                    Math.pow(r - bgColor.r, 2) * 0.3 +
                    Math.pow(g - bgColor.g, 2) * 0.59 +
                    Math.pow(b - bgColor.b, 2) * 0.11
                );

                const maxDistance = 255;
                const normalizedDistance = distance / maxDistance;

                if (normalizedDistance < tolerance / 100) {
                    alphaMap[idx] = 0;
                } else if (normalizedDistance < (tolerance + 20) / 100) {
                    alphaMap[idx] = Math.round(255 * (normalizedDistance - tolerance / 100) / (20 / 100));
                } else {
                    alphaMap[idx] = 255;
                }
            }

            if (feather > 0) {
                const blurredAlpha = gaussianBlur(alphaMap, colorProcessedPreview.width, colorProcessedPreview.height, feather);
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = blurredAlpha[i / 4];
                }
            } else {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = alphaMap[i / 4];
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // é«˜æ–¯æ¨¡ç³Š
        function gaussianBlur(data, width, height, radius) {
            const result = new Uint8Array(data.length);
            const size = radius * 2 + 1;
            const kernel = [];

            let sum = 0;
            for (let i = 0; i < size; i++) {
                const x = i - radius;
                const value = Math.exp(-(x * x) / (2 * radius * radius));
                kernel.push(value);
                sum += value;
            }
            for (let i = 0; i < size; i++) {
                kernel[i] /= sum;
            }

            const temp = new Uint8Array(data.length);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let weightSum = 0;
                    for (let i = 0; i < size; i++) {
                        const nx = x + i - radius;
                        if (nx >= 0 && nx < width) {
                            sum += data[y * width + nx] * kernel[i];
                            weightSum += kernel[i];
                        }
                    }
                    temp[y * width + x] = weightSum > 0 ? Math.round(sum / weightSum) : data[y * width + x];
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let weightSum = 0;
                    for (let i = 0; i < size; i++) {
                        const ny = y + i - radius;
                        if (ny >= 0 && ny < height) {
                            sum += temp[ny * width + x] * kernel[i];
                            weightSum += kernel[i];
                        }
                    }
                    result[y * width + x] = weightSum > 0 ? Math.round(sum / weightSum) : temp[y * width + x];
                }
            }

            return result;
        }

        // åå…­è¿›åˆ¶è½¬ RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // é¢œè‰²æŠ å›¾äº‹ä»¶ç›‘å¬
        colorToleranceSlider.addEventListener('input', (e) => {
            colorToleranceValue.textContent = e.target.value;
            processColorRemover();
        });

        colorFeatherSlider.addEventListener('input', (e) => {
            colorFeatherValue.textContent = e.target.value;
            processColorRemover();
        });

        colorBgColorPicker.addEventListener('input', () => {
            processColorRemover();
        });

        colorAutoDetectBtn.addEventListener('click', () => {
            autoDetectBackgroundColor();
            processColorRemover();
        });

        applyColorRemover.addEventListener('click', () => {
            applyColorRemoval();
        });

        skipColorRemover.addEventListener('click', () => {
            overlay.src = uploadedImageData;
            overlay.onload = () => {
                overlay.classList.add('visible');
                overlayLoaded = true;
                baseWidth = overlay.naturalWidth;
                baseHeight = overlay.naturalHeight;
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            };
            colorRemoverModal.classList.remove('active');
        });

        closeColorRemover.addEventListener('click', () => {
            colorRemoverModal.classList.remove('active');
        });

        function applyColorRemoval() {
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = uploadedImage.width;
            finalCanvas.height = uploadedImage.height;
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(uploadedImage, 0, 0);

            const imageData = finalCtx.getImageData(0, 0, finalCanvas.width, finalCanvas.height);
            const data = imageData.data;
            const bgColor = hexToRgb(colorBgColorPicker.value);
            const tolerance = colorToleranceSlider.value / 100;
            const feather = parseInt(colorFeatherSlider.value);

            const alphaMap = new Uint8Array(data.length / 4);

            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                const distance = Math.sqrt(
                    Math.pow(r - bgColor.r, 2) +
                    Math.pow(g - bgColor.g, 2) +
                    Math.pow(b - bgColor.b, 2)
                );

                const maxDistance = Math.sqrt(255 * 255 + 255 * 255 + 255 * 255);
                const similarity = distance / maxDistance;

                if (similarity < tolerance) {
                    alphaMap[idx] = 0;
                } else if (similarity < tolerance + 0.2) {
                    alphaMap[idx] = Math.round(255 * (similarity - tolerance) / 0.2);
                } else {
                    alphaMap[idx] = 255;
                }
            }

            if (feather > 0) {
                const blurredAlpha = alphaMap.slice();
                for (let i = 0; i < alphaMap.length; i++) {
                    const x = i % finalCanvas.width;
                    const y = Math.floor(i / finalCanvas.width);

                    let sum = 0;
                    let count = 0;

                    for (let dy = -feather; dy <= feather; dy++) {
                        for (let dx = -feather; dx <= feather; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < finalCanvas.width &&
                                ny >= 0 && ny < finalCanvas.height) {
                                const ni = ny * finalCanvas.width + nx;
                                sum += alphaMap[ni];
                                count++;
                            }
                        }
                    }

                    blurredAlpha[i] = Math.round(sum / count);
                }

                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = blurredAlpha[i / 4];
                }
            } else {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = alphaMap[i / 4];
                }
            }

            finalCtx.putImageData(imageData, 0, 0);

            overlay.src = finalCanvas.toDataURL('image/png');
            overlay.onload = () => {
                overlay.classList.add('visible');
                overlayLoaded = true;
                baseWidth = overlay.naturalWidth;
                baseHeight = overlay.naturalHeight;
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            };

            colorRemoverModal.classList.remove('active');
        }

        // æ—‹è½¬æ§åˆ¶
        rotateSlider.addEventListener('input', (e) => {
            rotation = parseInt(e.target.value);
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        rotateLeftBtn.addEventListener('click', () => {
            rotation = Math.max(-180, rotation - 15);
            rotateSlider.value = rotation;
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        rotateRightBtn.addEventListener('click', () => {
            rotation = Math.min(180, rotation + 15);
            rotateSlider.value = rotation;
            rotateValue.textContent = rotation + 'Â°';
            updateOverlayTransform();
        });

        // æ›´æ–°é€å¡å˜æ¢
        function updateOverlayTransform() {
            if (overlayLoaded) {
                overlayWrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
            }
        }

        // æ›´æ–°é€å¡å¤§å°
        function updateOverlaySize() {
            const containerWidth = window.innerWidth * 0.8;
            const containerHeight = window.innerHeight * 0.8;
            
            const aspectRatio = baseWidth / baseHeight;
            let newWidth, newHeight;
            
            if (aspectRatio > containerWidth / containerHeight) {
                newWidth = containerWidth;
                newHeight = containerWidth / aspectRatio;
            } else {
                newHeight = containerHeight;
                newWidth = containerHeight * aspectRatio;
            }
            
            overlay.style.width = (newWidth * scale) + 'px';
            overlay.style.height = (newHeight * scale) + 'px';
        }

        // æ»‘åŠ¨æ¡æ§åˆ¶ç¼©æ”¾
        scaleSlider.addEventListener('input', (e) => {
            scale = e.target.value / 100;
            scaleValue.textContent = e.target.value + '%';
            if (overlayLoaded) {
                updateOverlaySize();
            }
        });

        // é‡ç½®ä½ç½®
        function resetPosition() {
            overlayWrapper.style.left = '50%';
            overlayWrapper.style.top = '50%';
            overlayWrapper.style.transform = 'translate(-50%, -50%) rotate(0deg)';
        }

        resetBtn.addEventListener('click', () => {
            if (overlayLoaded) {
                scale = 1;
                rotation = 0;
                scaleSlider.value = 100;
                scaleValue.textContent = '100%';
                rotateSlider.value = 0;
                rotateValue.textContent = '0Â°';
                updateOverlaySize();
                resetPosition();
            }
        });

        // æ‹–æ‹½åŠŸèƒ½
        overlayWrapper.addEventListener('mousedown', startDrag);
        overlayWrapper.addEventListener('touchstart', startDrag, { passive: false });

        function startDrag(e) {
            if (!overlayLoaded) return;
            e.preventDefault();
            isDragging = true;
            
            const point = e.touches ? e.touches[0] : e;
            startX = point.clientX;
            startY = point.clientY;
            
            const rect = overlayWrapper.getBoundingClientRect();
            initialX = rect.left + rect.width / 2;
            initialY = rect.top + rect.height / 2;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();

            const point = e.touches ? e.touches[0] : e;
            const dx = point.clientX - startX;
            const dy = point.clientY - startY;

            const newX = initialX + dx;
            const newY = initialY + dy;

            overlayWrapper.style.left = newX + 'px';
            overlayWrapper.style.top = newY + 'px';
            overlayWrapper.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
        }

        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // åŒæŒ‡ç¼©æ”¾å’Œæ—‹è½¬
        let initialDistance = 0;
        let initialAngle = 0;
        let initialScale = 1;
        let initialRotation = 0;

        overlayWrapper.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2 && overlayLoaded) {
                e.preventDefault();
                initialDistance = getDistance(e.touches);
                initialAngle = getAngle(e.touches);
                initialScale = scale;
                initialRotation = rotation;
            }
        }, { passive: false });

        overlayWrapper.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && overlayLoaded) {
                e.preventDefault();
                const currentDistance = getDistance(e.touches);
                const currentAngle = getAngle(e.touches);

                const scaleFactor = currentDistance / initialDistance;
                scale = Math.min(2, Math.max(0.2, initialScale * scaleFactor));
                scaleSlider.value = Math.round(scale * 100);
                scaleValue.textContent = scaleSlider.value + '%';

                const angleDiff = currentAngle - initialAngle;
                rotation = initialRotation + angleDiff;

                while (rotation > 180) rotation -= 360;
                while (rotation < -180) rotation += 360;

                rotateSlider.value = Math.round(rotation);
                rotateValue.textContent = Math.round(rotation) + 'Â°';

                updateOverlaySize();
                updateOverlayTransform();

                initialDistance = currentDistance;
                initialAngle = currentAngle;
            }
        }, { passive: false });

        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAngle(touches) {
            const dx = touches[1].clientX - touches[0].clientX;
            const dy = touches[1].clientY - touches[0].clientY;
            return Math.atan2(dy, dx) * (180 / Math.PI);
        }

        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        overlayWrapper.addEventListener('wheel', (e) => {
            if (!overlayLoaded) return;
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.min(2, Math.max(0.2, scale * delta));
            scaleSlider.value = Math.round(scale * 100);
            scaleValue.textContent = scaleSlider.value + '%';

            updateOverlaySize();
        }, { passive: false });

        // æ‹ç…§
        captureBtn.addEventListener('click', () => {
            if (!overlayLoaded) {
                alert('è¯·å…ˆä¸Šä¼ é€å¡');
                return;
            }
            capturePhoto();
        });

        async function capturePhoto() {
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.opacity = '1';
            loadingText.textContent = 'æ­£åœ¨å¤„ç†ç…§ç‰‡...';

            const ctx = canvas.getContext('2d');
            const hasVideo = video.srcObject && video.readyState >= 2;
            const sourceImage = isAIEnabled ? outputCanvas : video;

            if (hasVideo && sourceImage) {
                let finalImageData;
                
                if (isAIEnabled) {
                    // AI æ¨¡å¼ï¼šéœ€è¦å…ˆå¤„ç†è§†é¢‘å¸§
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = video.videoWidth;
                    tempCanvas.height = video.videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(video, 0, 0);

                    tempCanvas.toBlob(async (blob) => {
                        try {
                            const resultBlob = await removeBackground(blob);
                            const resultImage = new Image();
                            resultImage.onload = () => {
                                canvas.width = resultImage.width;
                                canvas.height = resultImage.height;
                                ctx.drawImage(resultImage, 0, 0);

                                const sourceRect = outputCanvas.getBoundingClientRect();
                                const overlayRect = overlay.getBoundingClientRect();

                                const scaleX = canvas.width / sourceRect.width;
                                const scaleY = canvas.height / sourceRect.height;

                                const overlayX = (overlayRect.left - sourceRect.left) * scaleX;
                                const overlayY = (overlayRect.top - sourceRect.top) * scaleY;
                                const overlayWidth = overlayRect.width * scaleX;
                                const overlayHeight = overlayRect.height * scaleY;

                                ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);

                                capturedImageData = canvas.toDataURL('image/png');
                                previewImage.src = capturedImageData;
                                previewModal.classList.add('active');
                                loadingOverlay.style.opacity = '0';
                                setTimeout(() => {
                                    loadingOverlay.style.display = 'none';
                                }, 500);
                            };
                            resultImage.src = URL.createObjectURL(resultBlob);
                        } catch (error) {
                            console.error('AI å¤„ç†å¤±è´¥:', error);
                            alert('AI å¤„ç†å¤±è´¥ï¼Œå·²ä½¿ç”¨åŸå§‹ç…§ç‰‡');
                            
                            // å›é€€åˆ°ä½¿ç”¨åŸå›¾
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            ctx.drawImage(video, 0, 0);

                            const sourceRect = video.getBoundingClientRect();
                            const overlayRect = overlay.getBoundingClientRect();

                            const scaleX = canvas.width / sourceRect.width;
                            const scaleY = canvas.height / sourceRect.height;

                            const overlayX = (overlayRect.left - sourceRect.left) * scaleX;
                            const overlayY = (overlayRect.top - sourceRect.top) * scaleY;
                            const overlayWidth = overlayRect.width * scaleX;
                            const overlayHeight = overlayRect.height * scaleY;

                            ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);

                            capturedImageData = canvas.toDataURL('image/png');
                            previewImage.src = capturedImageData;
                            previewModal.classList.add('active');
                            loadingOverlay.style.opacity = '0';
                            setTimeout(() => {
                                loadingOverlay.style.display = 'none';
                            }, 500);
                        }
                    }, 'image/png');
                    return;
                } else {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);

                    const sourceRect = video.getBoundingClientRect();
                    const overlayRect = overlay.getBoundingClientRect();

                    const scaleX = canvas.width / sourceRect.width;
                    const scaleY = canvas.height / sourceRect.height;

                    const overlayX = (overlayRect.left - sourceRect.left) * scaleX;
                    const overlayY = (overlayRect.top - sourceRect.top) * scaleY;
                    const overlayWidth = overlayRect.width * scaleX;
                    const overlayHeight = overlayRect.height * scaleY;

                    ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);

                    capturedImageData = canvas.toDataURL('image/png');
                    previewImage.src = capturedImageData;
                    previewModal.classList.add('active');
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }
            } else {
                canvas.width = 1920;
                canvas.height = 1080;

                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const fallbackRect = document.getElementById('videoFallback').getBoundingClientRect();
                const overlayRect = overlay.getBoundingClientRect();

                const scaleX = canvas.width / fallbackRect.width;
                const scaleY = canvas.height / fallbackRect.height;

                const overlayX = (overlayRect.left - fallbackRect.left) * scaleX;
                const overlayY = (overlayRect.top - fallbackRect.top) * scaleY;
                const overlayWidth = overlayRect.width * scaleX;
                const overlayHeight = overlayRect.height * scaleY;

                ctx.drawImage(overlay, overlayX, overlayY, overlayWidth, overlayHeight);

                capturedImageData = canvas.toDataURL('image/png');
                previewImage.src = capturedImageData;
                previewModal.classList.add('active');
                loadingOverlay.style.opacity = '0';
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500);
            }
        }

        // ä¿å­˜ç…§ç‰‡
        saveBtn.addEventListener('click', () => {
            if (capturedImageData) {
                const link = document.createElement('a');
                link.download = `çµå½±ç…§ç‰‡_${Date.now()}.png`;
                link.href = capturedImageData;
                link.click();
            }
        });

        // é‡æ‹
        retakeBtn.addEventListener('click', () => {
            previewModal.classList.remove('active');
            capturedImageData = null;
        });

        // å…³é—­é¢„è§ˆ
        closePreview.addEventListener('click', () => {
            previewModal.classList.remove('active');
            capturedImageData = null;
        });

        // çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            if (overlayLoaded) {
                updateOverlaySize();
            }
        });

        // å¯åŠ¨åº”ç”¨
        initCamera();
    </script>
</body>
</html>
